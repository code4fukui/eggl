<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>wgld.org WebGL sample 009</title>
</head><body>

<script type="module">
import { mat4, identity, lookAt, perspective, multiply, rotate, translate, vec3, inverse } from "./mat4.js";
import { createVertexShader, createFragmentShader, createProgram, setAttributeVBO, createVBO, createIBO, createVAO } from "./glutil.js";
import { torus } from "./torus.js";
import { cube } from "./cube.js";
import { sphere } from "./sphere.js";

const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
canvas.onclick = () => canvas.requestFullscreen();
document.body.style.margin = 0;

const vs = `#version 300 es
/*
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;
layout (location = 2) in vec4 color;
*/
in vec3 position;
in vec3 normal;
in vec4 color;

uniform mat4 mMatrix;
uniform mat4 mvpMatrix;
uniform mat4 invMatrix;

out vec3 vPosition;
out vec3 vNormal;
flat out vec4 vColor;

void main() {
  vColor = color;
  vPosition = (mMatrix * vec4(position, 1.0)).xyz;
  vNormal = (invMatrix * vec4(normal, 0.0)).xyz;
  gl_Position = mvpMatrix * vec4(position, 1.0);
}
`;

const fs = `#version 300 es
precision highp float;

uniform vec3 lightPosition;
uniform vec3 eyePosition;

in vec3 vPosition;
in vec3 vNormal;
flat in vec4 vColor;

out vec4 outColor;

void main() {
  vec3 light = normalize(lightPosition - vPosition);
  vec3 eye = normalize(vPosition - eyePosition);
  vec3 ref = normalize(reflect(eye, vNormal));
  float diffuse = max(dot(light, vNormal), 0.8);
  float specular = max(dot(light, ref), 0.0);
  specular = pow(specular, 20.0);
  outColor = vec4(vColor.rgb * diffuse + specular, vColor.a);
}
`;

// webglコンテキストを取得
const gl = canvas.getContext("webgl2");

// 頂点シェーダとフラグメントシェーダの生成
const v_shader = createVertexShader(gl, vs);
const f_shader = createFragmentShader(gl, fs);

// プログラムオブジェクトの生成とリンク
const prg = createProgram(gl, v_shader, f_shader);

// attributeLocationを配列に取得
const attLocation = [
  gl.getAttribLocation(prg, "position"),
  gl.getAttribLocation(prg, "normal"),
  gl.getAttribLocation(prg, "color"),
];

// attributeの要素数を配列に格納
const attStride = [3, 3, 4];

// トーラスの頂点データを生成
//const obj = torus(400, 100, 3, 4);
const obj = torus(6, 10, 3, 4);
//const obj = cube(8);
//const obj = sphere(5, 8, 6);

// VBOの生成
const pos_vbo = createVBO(gl, obj.position);
const nor_vbo = createVBO(gl, obj.normal);
const col_vbo = createVBO(gl, obj.color);

// VBO を登録する
setAttributeVBO(gl, [pos_vbo, nor_vbo, col_vbo], attLocation, attStride);

// IBOの生成
const ibo = createIBO(gl, obj.index);

// IBOをバインドして登録する
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

// uniformLocationの取得
const uniMvpMatrix = gl.getUniformLocation(prg, "mvpMatrix");
const uniMMatrix = gl.getUniformLocation(prg, "mMatrix");
const uniInvMatrix = gl.getUniformLocation(prg, "invMatrix");
const uniLightPosition = gl.getUniformLocation(prg, "lightPosition");
const uniLightDirection = gl.getUniformLocation(prg, "lightDirection");
const uniEyeDirection = gl.getUniformLocation(prg, "eyeDirection");
const uniAmbientColor = gl.getUniformLocation(prg, "ambientColor");
const uniCameraPosition = gl.getUniformLocation(prg, "cameraPosition");

// ビュー×プロジェクション座標変換行列 tmpMatrix
const cameraPosition = vec3(0.0, 0.0, 20.0);
gl.uniform3fv(uniCameraPosition, cameraPosition);
const tmpMatrix = mat4();
const calcView = () => {
  const v = mat4();
  lookAt(v, cameraPosition, [0, 0, 0], [0, 1, 0]);
  const p = mat4();
  perspective(p, 45, canvas.width / canvas.height, 0.1, 100);
  multiply(tmpMatrix, p, v);
};

// ウィンドウリサイズ時に表示領域再設定
onresize = () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  calcView();
};
onresize();

// カリングと深度テストを有効にする
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);
gl.enable(gl.CULL_FACE);

// 並行光源
const lightDirection = vec3(-0.5, 0.5, 0.5);
gl.uniform3fv(uniLightDirection, lightDirection);
// 点光源？
const lightPosition = [25.0, 2.0, -25.0];
gl.uniform3fv(uniLightPosition, lightPosition);
// 視点ベクトル
const eyeDirection = [0.0, 0.0, 20.0];
gl.uniform3fv(uniEyeDirection, eyeDirection);
// 環境光の色
const ambientColor = [0.1, 0.1, 0.1, 1.0];
gl.uniform4fv(uniAmbientColor, ambientColor);

// 恒常ループ
const startt = performance.now();
const mMatrix = mat4(); // 計算用
const mvpMatrix = mat4();
const invMatrix = mat4();
const draw = () => {
  // 経過時間計算
  const t = performance.now() - startt;

  // canvasを初期化
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clearDepth(1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // モデル座標変換行列の生成
  identity(mMatrix);
  rotate(mMatrix, mMatrix, t * .0005, [0.5, .3, .7]);
  multiply(mvpMatrix, tmpMatrix, mMatrix);

  // モデル座標変換行列から逆行列を生成
  inverse(invMatrix, mMatrix);

  gl.uniformMatrix4fv(uniMMatrix, false, mMatrix);
  gl.uniformMatrix4fv(uniMvpMatrix, false, mvpMatrix);
  gl.uniformMatrix4fv(uniInvMatrix, false, invMatrix);
  gl.drawElements(gl.TRIANGLES, obj.index.length, gl.UNSIGNED_SHORT, 0);
  
  // コンテキストの再描画
  gl.flush();
  
  // 次の描画タイミングに再度呼ぶ
  requestAnimationFrame(draw);
};
draw();
</script>

</body></html>
