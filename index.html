<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>wgld.org WebGL sample 009</title>
</head><body>

<script type="module">
//import { mat4, identity, lookAt, perspective, multiply, rotate, translate, vec3, inverse, rotateQ, vec4, q2vec3 } from "./mat4.js";
//import { mat4, vec4, vec3, quat } from "./gl-matrix.js";
import { mat4, vec4, vec3, quat } from "https://glmatrix.net/src/index.js";
import { createVertexShader, createFragmentShader, createProgram, setAttributeVBO, createVBO, createIBO } from "./glutil.js";
import { torus } from "./torus.js";
import { cube } from "./cube.js";
import { sphere } from "./sphere.js";

const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
canvas.onclick = () => canvas.requestFullscreen();
document.body.style.margin = 0;

const vs = `
attribute vec3 position;
attribute vec3 normal;
attribute vec4 color;
uniform   mat4 mvpMatrix;
varying   vec3 vNormal;
varying   vec4 vColor;

void main(void){
  vNormal     = normal;
  vColor      = color;
  gl_Position = mvpMatrix * vec4(position, 1.0);
}
`;

const fs = `
precision mediump float;

uniform mat4 invMatrix;
uniform vec3 lightDirection;
uniform vec3 eyeDirection;
uniform vec4 ambientColor;
varying vec3 vNormal;
varying vec4 vColor;

void main(void){
  vec3  invLight  = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;
  vec3  invEye    = normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;
  vec3  halfLE    = normalize(invLight + invEye);
  float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);
  float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);
  vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;
  gl_FragColor    = destColor;
}
`;

// webglコンテキストを取得
const gl = canvas.getContext("webgl");

// 頂点シェーダとフラグメントシェーダの生成
const v_shader = createVertexShader(gl, vs);
const f_shader = createFragmentShader(gl, fs);

// プログラムオブジェクトの生成とリンク
const prg = createProgram(gl, v_shader, f_shader);

// attributeLocationを配列に取得
const attLocation = [
  gl.getAttribLocation(prg, "position"),
  gl.getAttribLocation(prg, "normal"),
  gl.getAttribLocation(prg, "color"),
];

// attributeの要素数を配列に格納
const attStride = [3, 3, 4];

// トーラスの頂点データを生成
//const obj = torus(400, 100, 3, 4);
const obj = torus(6, 10, 3, 4);
//const obj = cube(8);
//const obj = sphere(5, 8, 6);

// VBOの生成
const pos_vbo = createVBO(gl, obj.position);
const nor_vbo = createVBO(gl, obj.normal);
const col_vbo = createVBO(gl, obj.color);

// VBO を登録する
setAttributeVBO(gl, [pos_vbo, nor_vbo, col_vbo], attLocation, attStride);

// IBOの生成
const ibo = createIBO(gl, obj.index);

// IBOをバインドして登録する
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

// uniformLocationの取得
const uniMvpMatrix = gl.getUniformLocation(prg, "mvpMatrix");
const uniInvMatrix = gl.getUniformLocation(prg, "invMatrix");
const uniLightDirection = gl.getUniformLocation(prg, "lightDirection");
const uniEyeDirection = gl.getUniformLocation(prg, "eyeDirection");
const uniAmbientColor = gl.getUniformLocation(prg, "ambientColor");

// ウィンドウリサイズ時に表示領域再設定
onresize = () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};
onresize();

// カリングと深度テストを有効にする
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);
gl.enable(gl.CULL_FACE);

// 並行光源
const lightDirection = vec3.set(vec3.create(), -0.5, 0.5, 0.5);
gl.uniform3fv(uniLightDirection, lightDirection);
// 視点ベクトル
const eyeDirection = [0.0, 0.0, 20.0];
gl.uniform3fv(uniEyeDirection, eyeDirection);
// 環境光の色
const ambientColor = [0.1, 0.1, 0.1, 1.0];
gl.uniform4fv(uniAmbientColor, ambientColor);

// カメラの座標
const camPosition = vec3.create();

// カメラの上方向を表すベクトル
const camUpDirection = vec3.create();

// 恒常ループ
const startt = performance.now();
const mMatrix = mat4.create(); // 計算用
const pMatrix = mat4.create(); // temp
const vMatrix = mat4.create(); // temp
const tmpMatrix = mat4.create(); // temp
const mvpMatrix = mat4.create();
const invMatrix = mat4.create();
const xQuaternion = quat.create();

const draw = () => {
  // 経過時間計算
  const t = performance.now() - startt;

  // canvasを初期化
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clearDepth(1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // クォータニオンによる回転
  const rad2 = t * 0.001;
  //rotateQ(xQuaternion, rad2, [1, 0.0, 0.0]);
  quat.setAxisAngle(xQuaternion, [1, 0.0, 0.0], rad2);
  //q2vec3(camPosition, [0.0, 0.0, 20.0], xQuaternion);
  vec3.transformQuat(camPosition, [0.0, 0.0, 20.0], xQuaternion);
  //q2vec3(camUpDirection, [0.0, 1.0, 0.0], xQuaternion);
  vec3.transformQuat(camUpDirection, [0.0, 1.0, 0.0], xQuaternion);

  // ビュー×プロジェクション座標変換行列
  //lookAt(vMatrix, camPosition, [0, 0, 0], camUpDirection);
  mat4.lookAt(vMatrix, camPosition, [0, 0, 0], camUpDirection);
  //perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100);
  mat4.perspective(pMatrix, 45 / 180 * Math.PI, canvas.width / canvas.height, 0.1, 100);
  //multiply(tmpMatrix, pMatrix, vMatrix);
  mat4.multiply(tmpMatrix, pMatrix, vMatrix);

  // モデル座標変換行列の生成
  mat4.identity(mMatrix);
  mat4.rotate(mMatrix, mMatrix, t * .0005, [0.5, .3, .7]);
  mat4.multiply(mvpMatrix, tmpMatrix, mMatrix);

  // モデル座標変換行列から逆行列を生成
  mat4.invert(invMatrix, mMatrix);

  gl.uniformMatrix4fv(uniMvpMatrix, false, mvpMatrix);
  gl.uniformMatrix4fv(uniInvMatrix, false, invMatrix);
  gl.drawElements(gl.TRIANGLES, obj.index.length, gl.UNSIGNED_SHORT, 0);
  
  // コンテキストの再描画
  gl.flush();
  
  // 次の描画タイミングに再度呼ぶ
  requestAnimationFrame(draw);
};
draw();
</script>

</body></html>
