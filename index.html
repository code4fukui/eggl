<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>wgld.org WebGL2 sample 015</title>
</head><body>

<script type="module">
import { mat4, identity, lookAt, perspective, multiply, rotate, translate, vec3, inverse } from "./mat4.js";
import { createVertexShader, createFragmentShader, createProgram, createVBO, setAttributeVBO } from "./glutil.js";
import { waitImageLoad } from "https://js.sabae.cc/waitImageLoad.js";

const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
canvas.onclick = () => canvas.requestFullscreen();
document.body.style.margin = 0;
onresize = () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
};
onresize();

const touchHandler = (e) => {
  if (e.touches.length > 1) {
    e.preventDefault();
  }
};
addEventListener("touchstart", touchHandler, { passive: false });

const vs = `#version 300 es
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 velocity;
layout (location = 2) in vec4 color;

uniform float time;
uniform vec2 mouse; // -1.0 ~ 1.0
uniform float move; // 0.0 ~ 1.0
uniform int imgwidth;

out vec3 vPosition;
out vec3 vVelocity;
out vec4 vColor;

void main() {
  if (move > 0.001) {
    vPosition = position + velocity * 0.05 * move;
    vec3 p = vec3(mouse, sin(time) * 0.25) - position;
    vVelocity = normalize(velocity + p * 0.2 * move);
  } else {
    int n = gl_VertexID;
    int x = n % imgwidth;
    int y = n / imgwidth;
    float w = float(imgwidth / 2);
    vPosition = vec3(float(x) / w - 1.0, -float(y) / w + 1.0, 0);
    vVelocity = velocity;
  }
  vColor = color;
}
`;

const fs = `#version 300 es
precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(1.0);
}
`;

const vsmain = `#version 300 es
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 velocity;
layout (location = 2) in vec4 color;

uniform mat4 vpMatrix;
uniform float move;

out vec4 vColor;

void main() {
  vColor = color; //  + vec4(velocity, 0.0);
  gl_Position = vpMatrix * vec4(position, 1.0);
  gl_PointSize = 1.0; // * (1.0 + move);
}
`;

const fsmain = `#version 300 es
precision highp float;

in vec4 vColor;
out vec4 outColor;

void main() {
  outColor = vColor;
}
`;

// canvas
const mousePosition = [0.0, 0.0];
let isMousedown = false;
let mouseMovePower = 0.0;

// mousemove event
canvas.addEventListener("mousedown", function(eve){
  isMousedown = true;
  mouseMovePower = 1.0;
}, false);
canvas.addEventListener("mouseup", function(eve){
  isMousedown = false;
}, false);
canvas.addEventListener("mousemove", (e) => {
  const bound = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - bound.left;
  const y = e.clientY - bound.top;
  mousePosition[0] = x / bound.width * 2.0 - 1.0;
  mousePosition[1] = -(y / bound.height * 2.0 - 1.0);
}, false);

// generate imagedata
const img = new Image();
//img.src = "lenna.jpg";
img.src = "sabae.jpg";
await waitImageLoad(img);
const c = document.createElement("canvas");
const ctx = c.getContext("2d");
const imageWidth = img.width;
const imageHeight = img.height;
c.width = img.width;
c.height = img.height;
ctx.drawImage(img, 0, 0, imageWidth, imageHeight);
const targetImageData = ctx.getImageData(0, 0, imageWidth, imageHeight);

// transform feedback object
const gl = canvas.getContext("webgl2");
const transformFeedback = gl.createTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

// transform out shader
const prg = createProgram(
  gl,
  createVertexShader(gl, vs),
  createFragmentShader(gl, fs),
  ["vPosition", "vVelocity", "vColor"] // out variable names
);
const attLocation = [0, 1, 2];
const attStride = [3, 3, 4];
const uniLocation = [
  gl.getUniformLocation(prg, "time"),
  gl.getUniformLocation(prg, "mouse"),
  gl.getUniformLocation(prg, "move"),
  gl.getUniformLocation(prg, "imgwidth"),
];

// feedback in shader
const fPrg = createProgram(
  gl,
  createVertexShader(gl, vsmain),
  createFragmentShader(gl, fsmain)
);
const fAttLocation = [0, 1, 2];
const fAttStride = [3, 3, 4];
const fUniLocation = [
  gl.getUniformLocation(fPrg, "vpMatrix"),
  gl.getUniformLocation(fPrg, "move"),
];

// vertices
const position = [];
const velocity = [];
const color = [];
{
  for (let i = 0; i < imageHeight; i++) {
    const y = i / imageHeight * 2.0 - 1.0;
    const k = i * imageWidth;
    for (let j = 0; j < imageWidth; j++) {
      const x = j / imageWidth * 2.0 - 1.0;
      const l = (k + j) * 4;
      position.push(x, -y, 0.0);
      const m = Math.sqrt(x * x + y * y);
      velocity.push(x / m, -y / m, 0.0);
      color.push(
        targetImageData.data[l]     / 255,
        targetImageData.data[l + 1] / 255,
        targetImageData.data[l + 2] / 255,
        targetImageData.data[l + 3] / 255
      );
    }
  }
}
console.log(position.length / 3)

// create vbo
const vbos = [
  [
    createVBO(gl, position),
    createVBO(gl, velocity),
    createVBO(gl, color)
  ], [
    createVBO(gl, position),
    createVBO(gl, velocity),
    createVBO(gl, color)
  ]
];

// matrix
const mat = mat4();
const vMatrix = mat4();
const pMatrix = mat4();
const vpMatrix = mat4();
lookAt(vMatrix, [0.0, 0.0, 3.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);
perspective(pMatrix, 60, canvas.width / canvas.height, 0.1, 10.0);
multiply(vpMatrix, pMatrix, vMatrix);

// flags
gl.disable(gl.DEPTH_TEST);
gl.disable(gl.CULL_FACE);
gl.enable(gl.BLEND);
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
gl.disable(gl.RASTERIZER_DISCARD);

// setting
const startTime = performance.now();
let nowTime = 0;
let count = 0;

const render = () => {
  nowTime = performance.now() - startTime;

  // mouse move power
  if (!isMousedown) {
    mouseMovePower *= 0.99;
  }

  // increment
  ++count;
  const countIndex = count % 2;
  const invertIndex = 1 - countIndex;

  // program
  gl.useProgram(prg);

  // set vbo
  setAttributeVBO(gl, vbos[countIndex], attLocation, attStride);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, vbos[invertIndex][0]);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, vbos[invertIndex][1]);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, vbos[invertIndex][2]);

  // begin transform feedback
  gl.enable(gl.RASTERIZER_DISCARD);
  gl.beginTransformFeedback(gl.POINTS);

  // vertex transform
  gl.uniform1f(uniLocation[0], nowTime);
  gl.uniform2fv(uniLocation[1], mousePosition);
  gl.uniform1f(uniLocation[2], mouseMovePower);
  gl.uniform1i(uniLocation[3], imageWidth);
  gl.drawArrays(gl.POINTS, 0, position.length / 3);

  // end transform feedback
  gl.disable(gl.RASTERIZER_DISCARD);
  gl.endTransformFeedback();
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, null);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, null);

  // clear
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clearDepth(1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.viewport(0, 0, canvas.width, canvas.height);

  // program
  gl.useProgram(fPrg);

  // set vbo
  setAttributeVBO(gl, vbos[invertIndex], fAttLocation, fAttStride);

  // push and render
  gl.uniformMatrix4fv(fUniLocation[0], false, vpMatrix);
  gl.uniform1f(fUniLocation[1], mouseMovePower);
  gl.drawArrays(gl.POINTS, 0, position.length / 3);
  //gl.drawArrays(gl.LINES, 0, position.length / 3);
  //gl.drawArrays(gl.LINE_STRIP, 0, position.length / 3);
  //gl.drawArrays(gl.LINE_LOOP, 0, position.length / 3);
  
  gl.flush();

  // animation loop
  requestAnimationFrame(render);
};
render();

</script>

</body></html>
